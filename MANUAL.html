<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
<META NAME="generator" CONTENT="http://txt2tags.org">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<TITLE>NameTag: Name Entity Recognizer</TITLE>
</HEAD>
<BODY>

<DIV CLASS="header" ID="header">
<H1>NameTag: Name Entity Recognizer</H1>
<H2>Version 0.93</H2>
</DIV>

<DIV CLASS="toc">

  <OL>
  <LI><A HREF="#toc1">Introduction</A>
  <LI><A HREF="#toc2">Release</A>
    <UL>
    <LI><A HREF="#toc3">2.1. Download</A>
    <LI><A HREF="#toc4">2.2. Roadmap</A>
    <LI><A HREF="#toc5">2.3. License</A>
    <LI><A HREF="#toc6">2.4. Platforms and Requirements</A>
    </UL>
  <LI><A HREF="#toc7">NameTag Installation</A>
    <UL>
    <LI><A HREF="#toc8">3.1. Requirements</A>
    <LI><A HREF="#toc9">3.2. Compilation</A>
      <UL>
      <LI><A HREF="#toc10">3.2.1. Windows</A>
      </UL>
    <LI><A HREF="#toc11">3.3. Other language bindings</A>
      <UL>
      <LI><A HREF="#toc12">3.3.1. Java</A>
      <LI><A HREF="#toc13">3.3.2. Python</A>
      </UL>
    </UL>
  <LI><A HREF="#toc14">NameTag User's Manual</A>
    <UL>
    <LI><A HREF="#toc15">4.1. Models</A>
      <UL>
      <LI><A HREF="#toc16">4.1.1. Czech NER - CNEC 1.1</A>
      <LI><A HREF="#toc17">4.1.2. Czech NER - CNEC 2.0</A>
      </UL>
    <LI><A HREF="#run_ner">4.2. Running the Recognizer</A>
      <UL>
      <LI><A HREF="#run_ner_untokenized">4.2.1. Untokenized Input</A>
      <LI><A HREF="#run_ner_vertical">4.2.2. Vertical Input Format</A>
      </UL>
    <LI><A HREF="#toc21">4.3. Training of Custom Models</A>
      <UL>
      <LI><A HREF="#training_data">4.3.1. Training data</A>
      <LI><A HREF="#tagger">4.3.2. Tagger</A>
      <LI><A HREF="#feature_templates">4.3.3. Feature Templates</A>
      <LI><A HREF="#toc25">4.3.4. Running train_ner</A>
      </UL>
    </UL>
  <LI><A HREF="#toc26">NameTag API Reference</A>
    <UL>
    <LI><A HREF="#string_piece">5.1. Struct string_piece</A>
    <LI><A HREF="#token_range">5.2. Struct token_range</A>
    <LI><A HREF="#named_entity">5.3. Struct named_entity</A>
    <LI><A HREF="#tokenizer">5.4. Class tokenizer</A>
      <UL>
      <LI><A HREF="#tokenizer_set_text">5.4.1. tokenizer::set_text</A>
      <LI><A HREF="#tokenizer_next_sentence">5.4.2. tokenizer::next_sentence</A>
      </UL>
    <LI><A HREF="#ner">5.5. Class ner</A>
      <UL>
      <LI><A HREF="#ner_load_cstring">5.5.1. ner::load(const char*)</A>
      <LI><A HREF="#ner_load_FILE">5.5.2. ner::load(FILE*)</A>
      <LI><A HREF="#ner_recognize">5.5.3. ner::recognize</A>
      <LI><A HREF="#ner_tokenize_and_recognize">5.5.4. ner::tokenize_and_recognize</A>
      <LI><A HREF="#ner_new_tokenizer">5.5.5. ner::new_tokenizer</A>
      </UL>
    </UL>
  <LI><A HREF="#toc39">Contact</A>
  <LI><A HREF="#toc40">Acknowledgements</A>
  <LI><A HREF="#toc41">References</A>
    <UL>
    <LI><A HREF="#toc42">8.1. Bibtex for referencing</A>
    </UL>
  </OL>

</DIV>
<DIV CLASS="body" ID="body">

<A NAME="toc1"></A>
<H1>1. Introduction</H1>

<P>
NameTag is an open-source tool for named entity recognition (NER). NameTag
identifies proper names in text and classifies them into predefined categories,
such as names of persons, locations, organizations, etc. NameTag is distributed
as a standalone tool or a library, along with trained linguistic models. In the
Czech language, NameTag achieves state-of-the-art performance
(<A HREF="http://ufal.mff.cuni.cz/~straka/papers/2013-tsd_ner.pdf">Straková et al. 2013</A>).
NameTag is a free software under <A HREF="http://www.gnu.org/licenses/lgpl.html">LGPL</A>
license and the linguistic models are free for non-commercial use and
distributed under <A HREF="http://creativecommons.org/licenses/by-nc-sa/3.0/">CC BY-NC-SA</A>
license, although for some models the original data used to create the model
may impose additional licensing conditions.
</P>
<P>
Copyright 2014 by Institute of Formal and Applied Linguistics, Faculty of
Mathematics and Physics, Charles University in Prague, Czech Republic.
</P>

<A NAME="toc2"></A>
<H1>2. Release</H1>

<A NAME="toc3"></A>
<H2>2.1. Download</H2>

<P>
NameTag is currently undergoing beta testing. Please let us know if you wish to participate. The beta version includes:
</P>

<UL>
<LI>named entity recognizer commandline tool
<LI>Czech models trained on <A HREF="http://ufal.mff.cuni.cz/cnec/">CNEC</A> 1.1 and 2.0
<LI>C++ library
<LI>Java bindings
<LI>Python bindings
</UL>

<P>
NameTag will be available either as pre-compiled binaries and models from <A HREF="http://www.lindat.cz">LINDAT-Clarin</A> infrastructure or as open-source from <A HREF="https://github.com/ufal/nametag">GitHub</A>. If you use this tool for scientific work, please give credit to us by referencing <A HREF="http://ufal.mff.cuni.cz/nametag">NameTag website</A> and <A HREF="http://ufal.mff.cuni.cz/~straka/papers/2013-tsd_ner.pdf">Straková et al. 2013</A>.
</P>

<A NAME="toc4"></A>
<H2>2.2. Roadmap</H2>

<UL>
<LI><S>Feb 2014: training custom models available</S> (done)
<LI>Feb 2014: NameTag 1.0 release
<LI>March 2014: <S>Java</S> (done), <S>Python</S> (done), Perl language bindings
</UL>

<A NAME="toc5"></A>
<H2>2.3. License</H2>

<P>
NameTag is an open-source project and is freely available for non-commercial
purposes. The source code is distributed under <A HREF="http://www.gnu.org/licenses/lgpl.html">LGPL</A>
and the pre-compiled binaries and the associated models and data under
<A HREF="http://creativecommons.org/licenses/by-nc-sa/3.0/">CC BY-NC-SA</A>. If you use this tool for
scientific work, please give credit to us by referencing
<A HREF="http://ufal.mff.cuni.cz/nametag">NameTag website</A> and
<A HREF="http://ufal.mff.cuni.cz/~straka/papers/2013-tsd_ner.pdf">Straková et al. 2013</A>.
</P>

<A NAME="toc6"></A>
<H2>2.4. Platforms and Requirements</H2>

<P>
NameTag is available as a standalone tool and as a library for Linux/Windows.
It does not require any additional libraries. As any supervised machine
learning tool, it needs trained linguistic models to perform named entity
recognition. The models for the Czech language are available with the tool.
</P>

<A NAME="toc7"></A>
<H1>3. NameTag Installation</H1>

<P>
Pre-compiled binaries and models are available from <A HREF="http://www.lindat.cz">LINDAT-Clarin</A> infrastructure.
</P>
<P>
To use the NameTag library, either in C++ or other languages, it must be compiled manually. The sources are available either at <A HREF="http://www.lindat.cz">LINDAT-Clarin</A> or in the <A HREF="https://github.com/ufal/nametag">GitHub repository</A>.
</P>

<A NAME="toc8"></A>
<H2>3.1. Requirements</H2>

<UL>
<LI><CODE>G++ 4.7</CODE> or newer, alternatively <CODE>clang 3.2</CODE> or newer
<LI><CODE>make</CODE>
<LI><CODE>SWIG 2.0.5</CODE> or newer for language bindings other than <CODE>C++</CODE>
</UL>

<A NAME="toc9"></A>
<H2>3.2. Compilation</H2>

<P>
To compile NameTag on Unix-like systems, run <CODE>make</CODE> in the <CODE>src</CODE> directory.
</P>
<P>
Make targets and options:
</P>

<UL>
<LI><CODE>exe</CODE>: compile the binaries (default)
<LI><CODE>lib</CODE>: compile the library
<LI><CODE>BITS=32</CODE> or <CODE>BITS=64</CODE>: compile for specified 32-bit or 64-bit architecture instead of the default one
<LI><CODE>RELEASE=1</CODE>: turn off assertions and use LTO
<LI><CODE>PROFILE=1</CODE>: turn on profiling
<LI><CODE>DEBUG=1</CODE>: compile with debug informations and C++ library debugging
</UL>

<A NAME="toc10"></A>
<H3>3.2.1. Windows</H3>

<P>
Currently only G++ is supported under Windows. We use
<A HREF="http://tdm-gcc.tdragon.net/">TDM-GCC</A> for producing Windows builds,
but MinGW and Cygwin are also known to work. If you are interested in adding
support for other compilers (most notably, Visual Studio), let us know.
</P>
<P>
By default, Unix-like shell is required (i.e., Cygwin or MSYS). If you use
standard Windows Cmd.exe (i.e., TDM-GCC or plain MinGW), use
</P>

<PRE>
make WINCMD=1
</PRE>

<P>
Note that <CODE>make</CODE> in MinGW is usually distributed as <CODE>mingw32-make</CODE>.
</P>

<A NAME="toc11"></A>
<H2>3.3. Other language bindings</H2>

<A NAME="toc12"></A>
<H3>3.3.1. Java</H3>

<P>
To compile Java bindings, run <CODE>make</CODE> in the <CODE>bindings/java</CODE> directory,
optionally with the described Make options.
</P>
<P>
The Java installation specified in the environment variable <CODE>JAVA_HOME</CODE> is
used.  If the environment variable does not exist, the <CODE>JAVA_HOME</CODE> can be
specified using
</P>

<PRE>
make JAVA_HOME=path_to_Java_installation
</PRE>

<P>
Java 6 and newer is supported.
</P>

<A NAME="toc13"></A>
<H3>3.3.2. Python</H3>

<P>
To compile Python bindings, run <CODE>make</CODE> in the <CODE>bindings/python</CODE> directory,
optionally with the described Make options.
</P>
<P>
Path to the include headers of the required Python version must be specified
in the <CODE>PYTHON_INCLUDE</CODE> variable using
</P>

<PRE>
make PYTHON_INCLUDE=path_to_Python_includes
</PRE>

<P>
Both Python 2.6+ and Python 3+ are supported.
</P>

<A NAME="toc14"></A>
<H1>4. NameTag User's Manual</H1>

<P>
In a natural language text, the task of named entity recognition (NER) is to
identify proper names such as names of persons, organizations and locations.
NameTag recognizes named entities in an unprocessed text using
<A HREF="http://ufal.mff.cuni.cz/morphodita">MorphoDiTa</A>.
MorphoDiTa library tokenizes the text and performs morphologic analysis and tagging
and NameTag identifies and classifies named entities by an algorithm described in
<A HREF="http://ufal.mff.cuni.cz/~straka/papers/2013-tsd_ner.pdf">Straková et al. 2013</A>.
NameTag can also performs NER in custom tokenized and morphologically analyzed and
tagged texts.
</P>
<P>
This section describes the command line tool and the model.
</P>

<A NAME="toc15"></A>
<H2>4.1. Models</H2>

<P>
Like any supervised machine learning tool, NameTag needs a trained linguistic
model. Czech models trained on <A HREF="http://ufal.mff.cuni.cz/cnec/">CNEC</A> 1.1 and 2.0
are distributed with the tool. All models are distributed under the
<A HREF="http://creativecommons.org/licenses/by-nc-sa/3.0/">CC BY-NC-SA</A> licence.
Please make sure you are using the linguistic models in a version corresponding
to your NameTag release. The best way to assure this is to use the most
current NameTag release with the most current model release.
</P>

<A NAME="toc16"></A>
<H3>4.1.1. Czech NER - CNEC 1.1</H3>

<P>
The model is trained on the training portion of the <A HREF="http://ufal.mff.cuni.cz/cnec/">Czech Named Entity Corpus 1.1</A>.
The corpus uses a detailed two-level named entity hierarchy, whose description
is available in the documentation of the [Czech Named Entity Corpus 1.1
<A HREF="http://ufal.mff.cuni.cz/cnec/">http://ufal.mff.cuni.cz/cnec/</A>].
</P>

<A NAME="toc17"></A>
<H3>4.1.2. Czech NER - CNEC 2.0</H3>

<P>
The model is trained on the training portion of the <A HREF="http://ufal.mff.cuni.cz/cnec/">Czech Named Entity Corpus 2.0</A>.
The corpus uses a detailed two-level named entity hierarchy, whose description
is available in the documentation of the [Czech Named Entity Corpus 2.0
<A HREF="http://ufal.mff.cuni.cz/cnec/">http://ufal.mff.cuni.cz/cnec/</A>]. This hierarchy is an updated version of CNEC
1.1 hierarchy and is more suitable for automatic named entity recognition.
</P>

<A NAME="run_ner"></A>
<H2>4.2. Running the Recognizer</H2>

<P>
The NameTag Recognizer can be executed using the following command:
</P>

<PRE>
run_ner recognizer_model
</PRE>

<P>
The input is assumed to be in UTF-8 encoding and can be either already
tokenized and segmented, or it can be a plain text which is tokenized and
segmented automatically.
</P>
<P>
Any number of files can be specified after the <CODE>recognizer_model</CODE>. If an
argument <CODE>input_file:output_file</CODE> is used, the given <CODE>input_file</CODE> is
processed and the result is saved to <CODE>output_file</CODE>. If only <CODE>input_file</CODE> is
used, the result is saved to standard output. If no argument is given, input is
read from standard input and written to standard output.
</P>
<P>
The full command syntax of <CODE>run_ner</CODE> is
</P>

<PRE>
run_ner [-v] recognizer_model [input_file[:output_file]]...
</PRE>

<A NAME="run_ner_untokenized"></A>
<H3>4.2.1. Untokenized Input</H3>

<P>
By default (i.e., without specifying <CODE>-v</CODE>), the input is assumed to be
a plain text and it is automatically tokenized and segmented by default. The
output is in XML format without a root element, using
<CODE>&lt;ne type="..."&gt;...&lt;/ne&gt;</CODE> element to encode a named entity.
</P>
<P>
Example input file <CODE>sample.txt</CODE>:
</P>

<PRE>
Václav Havel byl český dramatik, esejista, kritik komunistického režimu a později politik.
</PRE>

<P>
NameTag is run using:
</P>

<PRE>
./run_ner recognizer_model sample.txt
</PRE>

<P>
A NameTag identifies a first name (<CODE>pf</CODE>), a surname (<CODE>ps</CODE>) and a person name container (<CODE>P</CODE>) in the input:
</P>

<PRE>
&lt;ne type='P'&gt;&lt;ne type='pf'&gt;Václav&lt;/ne&gt; &lt;ne type='ps'&gt;Havel&lt;/ne&gt;&lt;/ne&gt; byl český dramatik, esejista, kritik komunistického režimu a později politik.
</PRE>

<A NAME="run_ner_vertical"></A>
<H3>4.2.2. Vertical Input Format</H3>

<P>
If the input is already tokenized and segmented, <CODE>run_ner</CODE> accepts tokenized
and segmented text in a CoNLL-style vertical format, where every word is on
a separate line, with empty line representing an end of sentence.
</P>
<P>
The output in this case consists of lines representing found named entities.
Each line contains three tab-separated fields: <I>entity_range</I>, <I>entity_type</I> and
<I>entity_text</I>. The <I>entity_range</I> represents the lines of the input file containing
the named entity and <I>entity_type</I> represents its type. The <I>entity_text</I> is not
strictly necessary and contains space separated words of this named entity.
</P>
<P>
Example input:
</P>

<PRE>
Václav
Havel
byl
...
</PRE>

<P>
NameTag is run using:
</P>

<PRE>
./run_ner -v recognizer_model
</PRE>

<P>
Example output:
</P>

<PRE>
1,2	P	Václav Havel
1	pf	Václav
2	ps	Havel
...
</PRE>

<A NAME="toc21"></A>
<H2>4.3. Training of Custom Models</H2>

<P>
Training of custom models is possible using the <CODE>train_ner</CODE> binary.
</P>

<A NAME="training_data"></A>
<H3>4.3.1. Training data</H3>

<P>
To train a named entity recognizer model, training data is needed. The training
data must be tokenized and contain annotated name entities. The name entities
are non-overlapping, consist of a sequence of words and have a specified type.
</P>
<P>
The training data must be encoded in UTF-8 encoding. The lines correspond to
individual words and an empty line denotes an end of sentence. Each non-empty
line contains exactly two tab-separated columns, the first is the word form and the
second is the annotation. The format of the annotation is taken from CoNLL-2003:
the annotation <CODE>I-type</CODE> or <CODE>B-type</CODE> denotes named entity of specified type,
any other annotation is ignored. The <CODE>I-type</CODE> and <CODE>B-type</CODE> annotations are equivalent
except for one case &ndash; if the previous word is also a named entity of same type, then
</P>

 <UL>
 <LI>if the current word is annotated as <CODE>I-type</CODE>, it is part of the same named
   entity as the previous word,
 <LI>if the current word is annotated as <CODE>B-type</CODE>, it is in a different name entity
   than the previous word (albeit with the same type).
 </UL>

<A NAME="tagger"></A>
<H3>4.3.2. Tagger</H3>

<P>
Most named entity recognizer models utilize part of speech tags and lemmas.
NameTag can utilize several taggers to obtain the tags and lemmas:
</P>

<DL>
<DT><CODE>trivial</CODE></DT><DD>
  Do not use any tagger. The lemma is the same as the given form and there is
  no part of speech tag.
<P></P>
<DT><CODE>external</CODE></DT><DD>
  Use some external tagger. The input "forms" can contain multiple tab-separated values,
  first being the <I>form</I>, second the <I>lemma</I> and the rest is <I>part of speech tag</I>.
  The part of speech tag is optional. The lemma is also optional and if missing, the form
  itself is used as a lemma.
<P></P>
<DT><CODE>morphodita:model</CODE></DT><DD>
  Use <A HREF="http://ufal.mff.cuni.cz/morphodita">MorphoDiTa</A> as a tagger with the
  specified model. This tagger model is embedded in resulting named entity recognizer model.
  The <I>lemmatizer</I> model of MorphoDiTa is recommended, because it is very fast, small
  and detailed part of speech tags do not improve the performance of the named entity recognizer
  significantly.
</DL>

<H4>4.3.2.1. Lemma Structure</H4>

<P>
The lemmas used by the recognizer can be structured and consist of three parts:
</P>

<UL>
<LI><I>raw lemma</I> is the textual form of the lemma, possibly ambiguous
<LI><I>lemma id</I> is the unique lemma identification (for example a raw lemma plus
  a numeric identifier)
<LI><I>lemma info</I> is additional information about a lemma occurrence, not used
  to identify the lemma. If used, it usually contains information which is not
  possible to encode in part of speech tags.
</UL>

<P>
Currently, all these parts are filled only when <CODE>morphodita</CODE> tagger is used.
If <CODE>external</CODE> tagger is used, raw lemma and lemma id are the same and lemma
info is empty.
</P>

<A NAME="feature_templates"></A>
<H3>4.3.3. Feature Templates</H3>

<P>
The recognizer utilizes feature templates to generate features which are used
as the input to the named entity classifier. The feature templates are
specified in a file, one feature template on a line. Empty lines and lines
starting with <CODE>#</CODE> are ignored.
</P>
<P>
The first space-separated column on a line is the name of the feature template,
optionally followed by a slash and a window size. The window size specifies how
many adjacent words can observe the feature template value of a given word,
with default value of 0 denoting only the word in question.
</P>
<P>
List of commonly used feature templates follows. Note that it is probably not
exhaustive (see the sources in the <CODE>features</CODE> directory).
</P>

<UL>
<LI><CODE>BrownClusters file [prefix_lengths]</CODE> &ndash; use Brown clusters found in the
  specified file. An optional list of lengths of cluster prefixes to be used
  in addition to the full Brown cluster can be specified. Each line of the Brown
  clusters file must contain two tab-separated columns, the first of which is
  the Brown cluster label and the second is a raw lemma.
<LI><CODE>CzechLemmaTerm</CODE> &ndash; feature template specific for Czech morphologic system
  by Jan Hajič (<A HREF="http://books.google.cz/books?id=sB63AAAACAAJ">Hajič 2004</A>).
  The term information (personal name, geographic name, ...) specified in lemma
  info are used as features.
<LI><CODE>Form</CODE> &ndash; use forms as features
<LI><CODE>Gazetteers [files]</CODE> &ndash; use given files as gazetteers. Each file is one
  gazetteers list independent of the others and must contain a set of lemma
  sequences, each on a line, represented as raw lemmas separated by spaces.
<LI><CODE>Lemma</CODE> &ndash; use lemma ids as a feature
<LI><CODE>PreviousStage</CODE> &ndash; use named entities predicted by previous stage as features
<LI><CODE>RawLemma</CODE> &ndash; use raw lemmas as features
<LI><CODE>RawLemmaCapitalization</CODE> &ndash; use capitalization of raw lemma as features
<LI><CODE>Tag</CODE> &ndash; use tags as features
<LI><CODE>URLEmailDetector url_type email_type</CODE> &ndash; detect URLs and emails. If an URL
  or an email is detected, it is immediately marked with specified named entity
  type and not used in further processing.
</UL>

<A NAME="toc25"></A>
<H3>4.3.4. Running train_ner</H3>

<P>
The <CODE>train_ner</CODE> binary has the following arguments (which has to be specified
in this order):
</P>

<OL>
<LI><I>ner_identifier</I> &ndash; identifier of the named entity recognizer type. This affects
  the tokenizer used in this model, and in theory any other aspect of the recognizer.
  Supported values:
   <UL>
   <LI><I>czech</I>
   <P></P>
   </UL>
<LI><I>tagger</I> &ndash; the tagger identifier as described in the <A HREF="#tagger">Tagger</A> section
<P></P>
<LI><I>feature_templates_file</I> &ndash; file with feature templates as described in the
  <A HREF="#feature_templates">Feature Templates</A> section.
<P></P>
<LI><I>stages</I> &ndash; the number of stages performed during recognition. Common
  values are either <I>1</I> or <I>2</I>. With more stages, the model is larger and
  recognition is slower, but more accurate.
<P></P>
<LI><I>iterations</I> &ndash; the number of iterations performed when training each stage
  of the recognizer. With more iterations, training take longer (the
  recognition time is unaffected), but the model gets over-trained when too
  many iterations are used. Values from <I>10</I> to <I>30</I> or <I>50</I> are commonly used.
<P></P>
<LI><I>missing_weight</I> &ndash; default value of missing weights in the log-linear model.
  Common values are small negative real numbers like <I>-0.2</I>.
<P></P>
<LI><I>initial_learning_rage</I> &ndash; learning rate used in the first iteration of SGD
  training method of the log-linear model. Common value is <I>0.1</I>.
<P></P>
<LI><I>final_learning_rage</I> &ndash; learning rate used in the last iteration of SGD
  training method of the log-linear model. Common values are in range from
  <I>0.1</I> to <I>0.001</I>, with <I>0.01</I> working reasonably well.
<P></P>
<LI><I>gaussian</I> &ndash; the value of Gaussian prior imposed on the weights. In other
  words, value of L2-norm regularizer. Common value is either <I>0</I> for no regularization,
  or small real number like <I>0.5</I>.
<P></P>
<LI><I>hidden_layer</I> &ndash; experimental support for hidden layer in the artificial
  neural network classifier. To not use the hidden layer (recommended), use <I>0</I>.
  Otherwise, specify the number of neurons in the hidden layer. Please note that
  non-zero values will create enormous models, slower recognition and are
  <I>not</I> guaranteed to create models with better accuracy.
<P></P>
<LI><I>heldout_data</I> &ndash; optional parameter with heldout data in the
  <A HREF="#training_data">described</A> format. If the heldout data is present, the
  accuracy of the heldout data classification is printed during training. The
  heldout data is not used in any other way.
</OL>

<P>
The training data in the <A HREF="#training_data">described</A> format is read from the standard
input and the trained model is written to the standard output if the training
is successful.
</P>

<A NAME="toc26"></A>
<H1>5. NameTag API Reference</H1>

<P>
The NameTag API is defined in header <CODE>nametag.h</CODE> and resides in
<CODE>ufal::nametag</CODE> namespace.
</P>
<P>
The strings used in the NameTag API are always UTF-8 encoded (except from
file paths, whose encoding is system dependent).
</P>

<A NAME="string_piece"></A>
<H2>5.1. Struct string_piece</H2>

<PRE>
struct string_piece {
  const char* str;
  size_t len;

  string_piece();
  string_piece(const char* str);
  string_piece(const char* str, size_t len);
  string_piece(const std::string&amp; str);
}
</PRE>

<P>
The <A HREF="#string_piece"><CODE>string_piece</CODE></A> is used for efficient string passing. The string
referenced in <A HREF="#string_piece"><CODE>string_piece</CODE></A> is not owned by it, so users have to make sure
the referenced string exists as long as the <A HREF="#string_piece"><CODE>string_piece</CODE></A>.
</P>

<A NAME="token_range"></A>
<H2>5.2. Struct token_range</H2>

<PRE>
struct token_range {
  size_t start;
  size_t length;
};
</PRE>

<P>
The <A HREF="#token_range"><CODE>token_range</CODE></A> represent a range of a token as returned by a <A HREF="#tokenizer">tokenizer</A>.
The <CODE>start</CODE> and <CODE>length</CODE> fields specify the token position in Unicode
characters, not in bytes of UTF-8 encoding.
</P>

<A NAME="named_entity"></A>
<H2>5.3. Struct named_entity</H2>

<PRE>
struct named_entity {
  size_t start;
  size_t length;
  std::string type;

  named_entity();
  named_entity(size_t start, size_t length, const std::string&amp; type);
};
</PRE>

<P>
The <A HREF="#named_entity"><CODE>named_entity</CODE></A> is used to represend a named entity. The
<CODE>start</CODE> and <CODE>length</CODE> fields represent the entity range in either tokens,
unicode characters or bytes, depending on the usage. The <CODE>type</CODE> represents
the entity type.
</P>

<A NAME="tokenizer"></A>
<H2>5.4. Class tokenizer</H2>

<PRE>
class tokenizer {
 public:
  virtual ~tokenizer() {}

  virtual void <A HREF="#tokenizer_set_text">set_text</A>(<A HREF="#string_piece">string_piece</A> text, bool make_copy = false) = 0;
  virtual bool <A HREF="#tokenizer_next_sentence">next_sentence</A>(std::vector&lt;<A HREF="#string_piece">string_piece</A>&gt;* forms, std::vector&lt;<A HREF="#token_range">token_range</A>&gt;* tokens) = 0;
};
</PRE>

<P>
The <A HREF="#tokenizer"><CODE>tokenizer</CODE></A> class performs segmentation and tokenization of given text.
The class is <I>not</I> threadsafe.
</P>
<P>
The <A HREF="#tokenizer"><CODE>tokenizer</CODE></A> instances can be obtained only through instances of <A HREF="#ner"><CODE>ner</CODE></A>.
</P>

<A NAME="tokenizer_set_text"></A>
<H3>5.4.1. tokenizer::set_text</H3>

<PRE>
virtual void set_text(<A HREF="#string_piece">string_piece</A> text, bool make_copy = false) = 0;
</PRE>

<P>
Set the text which is to be tokenized.
</P>
<P>
If <CODE>make_copy</CODE> is <CODE>false</CODE>, only a reference to the given text is
stored and the user has to make sure it exists until the tokenizer
is released or <CODE>set_text</CODE> is called again. If <CODE>make_copy</CODE>
is <CODE>true</CODE>, a copy of the given text is made and retained until the
tokenizer is released or <CODE>set_text</CODE> is called again.
</P>

<A NAME="tokenizer_next_sentence"></A>
<H3>5.4.2. tokenizer::next_sentence</H3>

<PRE>
virtual bool next_sentence(std::vector&lt;<A HREF="#string_piece">string_piece</A>&gt;* forms, std::vector&lt;<A HREF="#token_range">token_range</A>&gt;* tokens) = 0;
</PRE>

<P>
Locate and return next sentence of the given text. Returns <CODE>true</CODE> when successful and <CODE>false</CODE> when
there are no more sentences in the given text. The arguments are filled with found tokens if not <CODE>NULL</CODE>.
The <CODE>forms</CODE> contain token ranges in bytes of UTF-8 encoding, the <CODE>tokens</CODE> contain token ranges
in Unicode characters.
</P>

<A NAME="ner"></A>
<H2>5.5. Class ner</H2>

<PRE>
class ner {
 public:
  virtual ~ner() {}

  static <A HREF="#ner">ner</A>* <A HREF="#ner_load_cstring">load</A>(const char* fname);
  static <A HREF="#ner">ner</A>* <A HREF="#ner_load_FILE">load</A>(FILE* f);

  virtual void <A HREF="#ner_recognize">recognize</A>(const std::vector&lt;<A HREF="#string_piece">string_piece</A>&gt;&amp; forms, std::vector&lt;<A HREF="#named_entity">named_entity</A>&gt;&amp; entities) const = 0;

  virtual <A HREF="#tokenizer">tokenizer</A>* <A HREF="#ner_new_tokenizer">new_tokenizer</A>() const = 0;
};
</PRE>

<P>
A <A HREF="#ner"><CODE>ner</CODE></A> instance represents a named entity recognizer. All methods
are thread-safe.
</P>

<A NAME="ner_load_cstring"></A>
<H3>5.5.1. ner::load(const char*)</H3>

<PRE>
static <A HREF="#ner">ner</A>* load(const char* fname);
</PRE>

<P>
Factory method constructor. Accepts C string with a file name of the model.
Returns a pointer to an instance of <A HREF="#ner"><CODE>ner</CODE></A> which the user should delete
after use.
</P>

<A NAME="ner_load_FILE"></A>
<H3>5.5.2. ner::load(FILE*)</H3>

<PRE>
static <A HREF="#ner">ner</A>* load(FILE* f);
</PRE>

<P>
Factory method constructor. Accepts C file pointer of an opened file with the
model. Returns a pointer to an instance of <A HREF="#ner"><CODE>ner</CODE></A> which the user should
delete after use.
</P>

<A NAME="ner_recognize"></A>
<H3>5.5.3. ner::recognize</H3>

<PRE>
virtual void recognize(const std::vector&lt;<A HREF="#string_piece">string_piece</A>&gt;&amp; forms, std::vector&lt;<A HREF="#named_entity">named_entity</A>&gt;&amp; entities) const = 0;
</PRE>

<P>
Perform named entity recognition on a tokenized sentence given in the <CODE>forms</CODE> argument.
The found entities are returned in the <CODE>entities</CODE> argument. The range of the
returned <A HREF="#named_entity">named_entity</A> is represented using form indices.
</P>

<A NAME="ner_tokenize_and_recognize"></A>
<H3>5.5.4. ner::tokenize_and_recognize</H3>

<PRE>
void tokenize_and_recognize(<A HREF="#string_piece">string_piece</A> text, std::vector&lt;<A HREF="#named_entity">named_entity</A>&gt;&amp; entities, bool unicode_offsets = false) const;
</PRE>

<P>
Perform named entity recognition on an untokenized text given in the <CODE>text</CODE> argument.
The found entities are returned in the <CODE>entities</CODE> argument. The range of the
returned <A HREF="#named_entity">named_entity</A> is represented either in Unicode characters
(when <CODE>unicode_offsets == true</CODE>), or in UTF-8 bytes (when <CODE>unicode_offset == false</CODE>).
</P>

<A NAME="ner_new_tokenizer"></A>
<H3>5.5.5. ner::new_tokenizer</H3>

<PRE>
virtual <A HREF="#tokenizer">tokenizer</A>* new_tokenizer() const = 0;
</PRE>

<P>
Returns a new instance of a suitable tokenizer or <CODE>NULL</CODE> if no such tokenizer
exists. The user should delete it after use.
</P>

<A NAME="toc39"></A>
<H1>6. Contact</H1>

<P>
Authors:
</P>

<UL>
<LI><A HREF="http://ufal.mff.cuni.cz/milan-straka">Milan Straka</A>, <A HREF="mailto:straka@ufal.mff.cuni.cz">straka@ufal.mff.cuni.cz</A>
<LI><A HREF="http://ufal.mff.cuni.cz/jana-strakova">Jana Straková</A>, <A HREF="mailto:strakova@ufal.mff.cuni.cz">strakova@ufal.mff.cuni.cz</A>
</UL>

<P>
<A HREF="http://ufal.mff.cuni.cz/nametag">NameTag website</A>.
</P>

<A NAME="toc40"></A>
<H1>7. Acknowledgements</H1>

<P>
This work has been using language resources developed and/or stored and/or distributed by the LINDAT-Clarin project of the Ministry of Education of the Czech Republic (project LM2010013).
</P>

<A NAME="toc41"></A>
<H1>8. References</H1>

<P>
Straková Jana, Straka Milan, Hajič Jan: <I><A HREF="http://ufal.mff.cuni.cz/~straka/papers/2013-tsd_ner.pdf">A New State-of-The-Art Czech Named Entity Recognizer</A>.</I> In: Lecture Notes in Computer Science, Vol. 8082, Text, Speech and Dialogue: 16th International Conference, TSD 2013. Proceedings, Copyright © Springer Verlag, Berlin / Heidelberg, ISBN 978-3-642-40584-6, ISSN 0302-9743, pp. 68-75, 2013
</P>

<A NAME="toc42"></A>
<H2>8.1. Bibtex for referencing</H2>

<PRE>
  @inproceedings{biblio:StStANew2013,
    booktitle = {Text, Speech and Dialogue: 16th International Conference, {TSD} 2013. Proceedings},
    series = {Lecture Notes in Computer Science},
    title = {A New State-of-The-Art Czech Named Entity Recognizer},
    editor = {Ivan Habernal and V{\'{a}}clav Matou{\v{s}}ek},
    author = {Jana Strakov{\'{a}} and Milan Straka and Jan Haji{\v{c}}},
    year = {2013},
    publisher = {Springer Verlag},
    organization = {Z{\'{a}}pado{\v{c}}esk{\'{a}} univerzita v Plzni},
    address = {Berlin / Heidelberg},
    venue = {Plze{\v{n}}, hotel Angelo},
    series = {Lecture Notes in Artificial Intelligence},
    volume = {8082},
    pages = {68--75},
    isbn = {978-3-642-40584-6},
    issn = {0302-9743},
  }
</PRE>

</DIV>
<!-- html code generated by txt2tags 2.6 (http://txt2tags.org) -->
<!-- cmdline: txt2tags -t html -C ../morphodita/doc/not_web.conf nametag.t2t -->
</BODY></HTML>
