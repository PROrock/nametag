NameTag API Reference
=====================

%!encoding: utf-8

The NameTag API is defined in header ``nametag.h`` and resides in
``ufal::nametag`` namespace.

The strings used in the NameTag API are always UTF-8 encoded (except from
file paths, whose encoding is system dependent).

== Struct string_piece ==[string_piece]
```
struct string_piece {
  const char* str;
  size_t len;

  string_piece();
  string_piece(const char* str);
  string_piece(const char* str, size_t len);
  string_piece(const std::string& str);
}
```

The [``string_piece`` #string_piece] is used for efficient string passing. The string
referenced in [``string_piece`` #string_piece] is not owned by it, so users have to make sure
the referenced string exists as long as the [``string_piece`` #string_piece].


== Struct token_range ==[token_range]
```
struct token_range {
  size_t start;
  size_t length;
};
```

The [``token_range`` #token_range] represent a range of a token as returned by a [tokenizer #tokenizer].
The ``start`` and ``length`` fields specify the token position in Unicode
characters, not in bytes of UTF-8 encoding.


== Struct named_entity ==[named_entity]
```
struct named_entity {
  size_t start;
  size_t length;
  std::string type;

  named_entity();
  named_entity(size_t start, size_t length, const std::string& type);
};
```

The [``named_entity`` #named_entity] is used to represend a named entity. The
``start`` and ``length`` fields represent the entity range in either tokens,
unicode characters or bytes, depending on the usage. The ``type`` represents
the entity type.


== Class tokenizer ==[tokenizer]
```
class tokenizer {
 public:
  virtual ~tokenizer() {}

  virtual void [set_text #tokenizer_set_text]([string_piece #string_piece] text, bool make_copy = false) = 0;
  virtual bool [next_sentence #tokenizer_next_sentence](std::vector<[string_piece #string_piece]>* forms, std::vector<[token_range #token_range]>* tokens) = 0;
};
```

The [``tokenizer`` #tokenizer] class performs segmentation and tokenization of given text.
The class is //not// threadsafe.

The [``tokenizer`` #tokenizer] instances can be obtained only through instances of [``ner`` #ner].

=== tokenizer::set_text ===[tokenizer_set_text]
``` virtual void set_text([string_piece #string_piece] text, bool make_copy = false) = 0;

Set the text which is to be tokenized.

If ``make_copy`` is ``false``, only a reference to the given text is
stored and the user has to make sure it exists until the tokenizer
is released or ``set_text`` is called again. If ``make_copy``
is ``true``, a copy of the given text is made and retained until the
tokenizer is released or ``set_text`` is called again.

=== tokenizer::next_sentence ===[tokenizer_next_sentence]
``` virtual bool next_sentence(std::vector<[string_piece #string_piece]>* forms, std::vector<[token_range #token_range]>* tokens) = 0;

Locate and return next sentence of the given text. Returns ``true`` when successful and ``false`` when
there are no more sentences in the given text. The arguments are filled with found tokens if not ``NULL``.
The ``forms`` contain token ranges in bytes of UTF-8 encoding, the ``tokens`` contain token ranges
in Unicode characters.


== Class ner ==[ner]
```
class ner {
 public:
  virtual ~ner() {}

  static [ner #ner]* [load #ner_load_cstring](const char* fname);
  static [ner #ner]* [load #ner_load_FILE](FILE* f);

  virtual void [recognize #ner_recognize](const std::vector<[string_piece #string_piece]>& forms, std::vector<[named_entity #named_entity]>& entities) const = 0;

  virtual [tokenizer #tokenizer]* [new_tokenizer #ner_new_tokenizer]() const = 0;
};
```

A [``ner`` #ner] instance represents a named entity recognizer. All methods
are thread-safe.

=== ner::load(const char*) ===[ner_load_cstring]
``` static [ner #ner]* load(const char* fname);

Factory method constructor. Accepts C string with a file name of the model.
Returns a pointer to an instance of [``ner`` #ner] which the user should delete
after use.

=== ner::load(FILE*) ===[ner_load_FILE]
``` static [ner #ner]* load(FILE* f);

Factory method constructor. Accepts C file pointer of an opened file with the
model. Returns a pointer to an instance of [``ner`` #ner] which the user should
delete after use.

=== ner::recognize ===[ner_recognize]
``` virtual void recognize(const std::vector<[string_piece #string_piece]>& forms, std::vector<[named_entity #named_entity]>& entities) const = 0;

Perform named entity recognition on a tokenized sentence given in the ``forms`` argument.
The found entities are returned in the ``entities`` argument. The range of the
returned [named_entity #named_entity] is represented using form indices.


=== ner::tokenize_and_recognize ===[ner_tokenize_and_recognize]
``` void tokenize_and_recognize([string_piece #string_piece] text, std::vector<[named_entity #named_entity]>& entities, bool unicode_offsets = false) const;

Perform named entity recognition on an untokenized text given in the ``text`` argument.
The found entities are returned in the ``entities`` argument. The range of the
returned [named_entity #named_entity] is represented either in Unicode characters
(when ``unicode_offsets == true``), or in UTF-8 bytes (when ``unicode_offset == false``).


=== ner::new_tokenizer ===[ner_new_tokenizer]
``` virtual [tokenizer #tokenizer]* new_tokenizer() const = 0;

Returns a new instance of a suitable tokenizer or ``NULL`` if no such tokenizer
exists. The user should delete it after use.
